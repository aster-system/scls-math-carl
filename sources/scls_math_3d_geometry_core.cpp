//******************
//
// scls_math_3d_geometry_core.cpp
//
//******************
// Presentation :
//
// SCLS is a project containing base functions for C++.
// It can also be use in any projects.
//
// The Math "Carl" part represents the mathematical part of SCLS.
// It is named after one one of the greatest mathematician of all times, Carl Freiderich Gauss.
//
// This file contains the source code of scls_math_geometry_core.h.
//
//******************
//
// License (LGPL V3.0) :
//
// Copyright (C) 2024 by Aster System, Inc. <https://aster-system.github.io/aster-system/>
// This file is part of SCLS.
// SCLS is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
// SCLS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with SCLS. If not, see <https://www.gnu.org/licenses/>.
//

// Include the good header file
#include "../scls_math_directory/scls_math_3d_core.h"

// The namespace "scls" is used to simplify the all.
namespace scls {

    // Extremums
    // TO OPTIMISE
    double Transform_Object_3D::max_absolute_x() const {Point_3D absolute_max = absolute_scale()/2.0;absolute_max.rotate(absolute_rotation());return absolute_x() + absolute_max.x();};
    double Transform_Object_3D::max_absolute_y() const {Point_3D absolute_max = absolute_scale()/2.0;absolute_max.rotate(absolute_rotation());return absolute_y() + absolute_max.y();};
    double Transform_Object_3D::min_absolute_x() const {Point_3D absolute_max = absolute_scale()/2.0;absolute_max.rotate(absolute_rotation());return absolute_x() - absolute_max.x();};
    double Transform_Object_3D::min_absolute_y() const {Point_3D absolute_max = absolute_scale()/2.0;absolute_max.rotate(absolute_rotation());return absolute_y() - absolute_max.y();};

    // Precise next movement
    double Transform_Object_3D::max_absolute_x_next() const {return max_absolute_x() + next_movement_x();};
    double Transform_Object_3D::max_absolute_y_next() const {return max_absolute_y() + next_movement_y();};
    double Transform_Object_3D::min_absolute_x_next() const {return min_absolute_x() + next_movement_x();};
    double Transform_Object_3D::min_absolute_y_next() const {return min_absolute_y() + next_movement_y();};
    Point_3D Transform_Object_3D::position_next() const {return Point_3D(x() + next_movement_x(), y() + next_movement_y(), z());};

    // Next movement generated by the velocity
    double Transform_Object_3D::next_movement_x()const{return velocity().x() * a_delta_time.to_double();};
    double Transform_Object_3D::next_movement_y()const{return velocity().y() * a_delta_time.to_double();};

    // Next position
    double Transform_Object_3D::x_next() const {return x() + next_movement_x();};
    double Transform_Object_3D::y_next() const {return y() + next_movement_y();};
}
