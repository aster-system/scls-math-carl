//******************
//
// scls_math_3d_physic.h
//
//******************
// Presentation :
//
// SCLS is a project containing base functions for C++.
// It can also be use in any projects.
//
// The Math "Carl" part represents the mathematical part of SCLS.
// It is named after one one of the greatest mathematician of all times, Carl Freiderich Gauss.
//
// This file contains some tools to use 3D physic in SCLS.
//
//******************
//
// License (LGPL V3.0) :
//
// Copyright (C) 2024 by Aster System, Inc. <https://aster-system.github.io/aster-system/>
// This file is part of SCLS.
// SCLS is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
// SCLS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with SCLS. If not, see <https://www.gnu.org/licenses/>.
//

// Include the good header file
#include "scls_math_3d_core.h"

// The namespace "scls" is used to simplify the all.
namespace scls {
    // Possible types of collision
    enum Collision_Type_3D {CT_3D_Sphere, CT_3D_Line, CT_3D_Cube};

    // Physic in a graphic object
    class Physic_Object_3D {
        // Class representating a physic handler in a graphic object
    public:

        // Collision
        class Collision_3D {
            // Class representating a collision in a graphic object
        public:

            // Base of a collision
            struct Collision_Event {
                // Collision constructor
                Collision_Event(std::weak_ptr<Collision_3D> collision_parent):a_collision_parent(collision_parent){}

                // This object
                Collision_3D* collision_parent() const {return a_collision_parent.lock().get();};
                std::weak_ptr<Collision_3D> collision_parent_weak_ptr() const {return a_collision_parent;};

                // If the collision happens or not
                bool happens = false;
                Collision_Type_3D type;

                // Other collided object
                Physic_Object_3D* attached_physic(){return a_collision_parent.lock().get()->attached_physic();};
                Collision_3D* other_collision(){return a_other_collision.lock().get();};
                Collision_Event* other_collision_event(){return a_other_collision_event.lock().get();};
                Physic_Object_3D* other_physic(){return a_other_collision.lock().get()->attached_physic();};
                void set_other_collision_event(std::weak_ptr<Collision_Event> new_other_collision_event){a_other_collision_event = new_other_collision_event;a_other_collision = other_collision_event()->collision_parent_weak_ptr();};

                // Acceleration generated by the force
                Point_3D acceleration;

                // Position of the collision
                Point_3D a_collision_position;
                void set_collision_position(Point_3D new_position){a_collision_position = new_position;};

            private:

                // Parent collision of this object
                std::weak_ptr<Collision_3D> a_collision_parent;

                // Other collision object
                std::weak_ptr<Collision_3D> a_other_collision;
                std::weak_ptr<Collision_Event> a_other_collision_event;
            };

            // Datas for a circle collision
            struct Collision_Event_Circle : public Collision_Event {
                // Collision_Circle constructor
                Collision_Event_Circle(std::weak_ptr<Collision_3D> collision_parent):Collision_Event(collision_parent){type = Collision_Type_3D::CT_3D_Sphere;};

                // Angle of the collision
                double angle;
            };

            // Datas for a rect collision
            struct Collision_Event_Rect_Rect : public Collision_Event {
                // Possible side for collision
                #define PLEOS_PHYSIC_RECT_COLLISION_BOTTOM 3
                #define PLEOS_PHYSIC_RECT_COLLISION_LEFT 2
                #define PLEOS_PHYSIC_RECT_COLLISION_RIGHT 4
                #define PLEOS_PHYSIC_RECT_COLLISION_TOP 1

                // Collision_Rect_Rect constructor
                Collision_Event_Rect_Rect(std::weak_ptr<Collision_3D> collision_parent):Collision_Event(collision_parent){type = Collision_Type_3D::CT_3D_Cube;};

                // Distance between the colliding side
                double distance;
                // Sides of the collision
                bool side_backward = false;
                bool side_bottom = false;
                bool side_forward = false;
                bool side_left = false;
                bool side_right = false;
                bool side_top = false;
            };

            // Collision constructor
            Collision_3D(std::weak_ptr<Physic_Object_3D> attached_physic, std::weak_ptr<Transform_Object_3D> attached_transform):a_attached_physic(attached_physic),a_attached_transform(attached_transform){};

            // Getters and setters
            scls::Fraction absolute_height() const;
            Point_3D absolute_scale() const;
            scls::Fraction absolute_width() const;
            double absolute_x() const;
            double absolute_x_1() const;
            double absolute_x_2() const;
            double absolute_y() const;
            double absolute_y_1() const;
            double absolute_y_2() const;
            Physic_Object_3D* attached_physic()const;
            Transform_Object_3D* attached_transform()const;
            double direct_x_1() const;
            double direct_x_2() const;
            double direct_y_1() const;
            double direct_y_2() const;
            double max_absolute_x() const;
            double max_absolute_y() const;
            double min_absolute_x() const;
            double min_absolute_y() const;
            double max_absolute_x_next() const;
            double max_absolute_y_next() const;
            double max_absolute_z_next() const;
            double min_absolute_x_next() const;
            double min_absolute_y_next() const;
            double min_absolute_z_next() const;
            scls::Point_3D position_next() const;
            void set_type(Collision_Type_3D new_type);
            void set_x_1(scls::Fraction new_x_1);
            void set_x_2(scls::Fraction new_x_2);
            void set_y_1(scls::Fraction new_y_1);
            void set_y_2(scls::Fraction new_y_2);
            Collision_Type_3D type()const;
            double x_1() const;
            double x_2() const;
            double y_1() const;
            double y_2() const;

        private:
            // Attached physic
            std::weak_ptr<Physic_Object_3D> a_attached_physic;
            // Attached object
            std::weak_ptr<Transform_Object_3D> a_attached_transform;
            // Type of the collision
            Collision_Type_3D a_type = Collision_Type_3D::CT_3D_Cube;

            // Two points (needed for lines)
            scls::Fraction a_x_1 = 0;scls::Fraction a_y_1 = 0;
            scls::Fraction a_x_2 = 0;scls::Fraction a_y_2 = 0;
        };

        // Physic case
        struct Physic_Case{
            // Static objects in the case
            inline void delete_static_object_collision(Collision_3D* object){for(int i=0;i<static_cast<int>(static_objects_collisions.size());i++){if(static_objects_collisions[i].lock().get()==object){static_objects_collisions.erase(static_objects_collisions.begin() + i);static_objects_collisions_physic.erase(static_objects_collisions_physic.begin() + i);break;}}};
            std::vector<std::weak_ptr<Collision_3D>> static_objects_collisions;
            std::vector<std::weak_ptr<Physic_Object_3D>> static_objects_collisions_physic;

            // Position
            Point_3D position;
            inline int x(){return position.x();};
        };

        // Physic_Object_3D constructor
        Physic_Object_3D(std::weak_ptr<Transform_Object_3D> attached_transform):a_attached_transform(attached_transform){};

        // Deletes the object
        void delete_object();
        // If the object should be deleted or not
        bool should_delete() const;
        // Softs reset the object
        virtual void soft_reset();

        // Add a line / rect collision to the graphic object
        void add_collision(std::shared_ptr<Collision_3D> collision);
        // Checks if a collision occurs with an another collision
        void check_collision(std::shared_ptr<Collision_3D> collision, Physic_Object_3D* other_object);
        // Returns a new a collision to the graphic object
        std::shared_ptr<Collision_3D> new_collision(Collision_Type_3D type);
        std::shared_ptr<Collision_3D> new_collision(){return new_collision(Collision_Type_3D::CT_3D_Cube);};

        // Accelerates the object
        inline void accelerate(scls::Point_3D acceleration){a_attached_transform.lock().get()->accelerate(acceleration);};
        inline void accelerate_x(double acceleration){a_attached_transform.lock().get()->accelerate_x(acceleration);};
        inline void accelerate_y(double acceleration){a_attached_transform.lock().get()->accelerate_y(acceleration);};
        // Next movement generated by the velocity
        inline double next_movement_x()const{return a_attached_transform.lock().get()->next_movement_x();};
        inline double next_movement_y()const{return a_attached_transform.lock().get()->next_movement_y();};

        // Moves the object
        void __move(Point_3D point){Transform_Object_3D* t=a_attached_transform.lock().get();t->set_x(t->x() + point.x());t->set_y(t->y() + point.y());};
        void __move(){Transform_Object_3D* t=a_attached_transform.lock().get();t->add_x(next_movement_x());t->add_y(next_movement_y());};

        // Physic
        virtual int collision_depht(){return std::ceil(max_absolute_z_next()) - std::floor(min_absolute_z_next());};
        virtual int collision_height(){return std::ceil(max_absolute_y_next()) - std::floor(min_absolute_y_next());};
        virtual int collision_width(){return std::ceil(max_absolute_x_next()) - std::floor(min_absolute_x_next());};
        virtual int collision_x_start(){return std::floor(min_absolute_x_next());};
        virtual int collision_y_start(){return std::floor(min_absolute_y_next());};
        virtual int collision_z_start(){return std::floor(min_absolute_z_next());};

        // Precise next movement
        inline double max_absolute_x_next() const {return attached_transform()->max_absolute_x_next();};
        inline double max_absolute_y_next() const {return attached_transform()->max_absolute_y_next();};
        inline double max_absolute_z_next() const {return attached_transform()->max_absolute_z_next();};
        inline double min_absolute_x_next() const {return attached_transform()->min_absolute_x_next();};
        inline double min_absolute_y_next() const {return attached_transform()->min_absolute_y_next();};
        inline double min_absolute_z_next() const {return attached_transform()->min_absolute_z_next();};
        inline Point_3D position_next() const {return attached_transform()->position_next();};
        inline double x_next() const {return attached_transform()->x_next();};
        inline double y_next() const {return attached_transform()->y_next();};

        // Calculates the point of the trajectory of the function
        std::vector<Point_3D> trajectory_points(int point_number, double time_separation);

        // Getters and setters
        inline scls::Transform_Object_3D* attached_transform()const{return a_attached_transform.lock().get();};
        inline std::vector<std::shared_ptr<Collision_3D>>& collisions(){return a_collisions;};
        inline std::vector<std::shared_ptr<Collision_3D::Collision_Event>>& current_collisions_results(){return a_current_collisions_results;};
        inline scls::Fraction delta_time() const {return a_delta_time;};
        inline bool ignore_dynamic_collisions() const {return a_ignore_dynamic_collisions;};
        inline bool is_static() const {return a_static;};
        inline bool loaded_in_map() const {return a_loaded_in_map;};
        inline bool moved_during_this_frame() const {return attached_transform()->moved_during_this_frame();};
        inline scls::Point_3D position() const {return a_attached_transform.lock().get()->position();};
        inline double restitution() const {return a_restitution;};
        inline bool save_to_xml_text() const {return a_save_to_xml_text;};
        inline void set_delta_time(scls::Fraction new_delta_time){a_delta_time = new_delta_time;attached_transform()->set_delta_time(new_delta_time);for(int i = 0;i<static_cast<int>(a_collisions.size());i++){a_collisions.at(i).get()->attached_transform()->set_delta_time(new_delta_time);}};
        inline void set_ignore_dynamic_collisions(bool new_ignore_dynamic_collisions){a_ignore_dynamic_collisions = new_ignore_dynamic_collisions;};
        inline void set_loaded_in_map(bool new_loaded_map){a_loaded_in_map = new_loaded_map;};
        inline void set_restitution(double new_restitution){a_restitution = new_restitution;};
        inline void set_save_to_xml_text(bool new_save_to_xml_text){a_save_to_xml_text = new_save_to_xml_text;};
        inline void set_static(bool new_static) {a_static = new_static;}
        inline void set_this_object(std::weak_ptr<Physic_Object_3D> this_object) {a_this_object = this_object;}
        inline void set_use_gravity(bool new_use_gravity){a_use_gravity = new_use_gravity;};
        inline void set_velocity(Point_3D new_velocity){attached_transform()->set_velocity(new_velocity);};
        inline bool use_gravity() const {return a_use_gravity;};
        inline std::vector<Physic_Case*>& used_physic_case(){return a_used_physic_case;};
        inline scls::Point_3D velocity() const {return a_attached_transform.lock().get()->velocity();};
        inline double velocity_x() {return velocity().x();};
        inline double velocity_y() {return velocity().y();};
        inline scls::Fraction x() {return attached_transform()->x();};
        inline scls::Fraction y() {return attached_transform()->y();};
    private:
        // Attached object
        std::weak_ptr<scls::Transform_Object_3D> a_attached_transform;
        // Collisions in the physic object
        std::vector<std::shared_ptr<Collision_3D>> a_collisions;
        // Current collision of the object
        std::vector<std::shared_ptr<Collision_3D::Collision_Event>> a_current_collisions_results;
        // This object
        std::weak_ptr<Physic_Object_3D> a_this_object;

        // Delta time of the object
        scls::Fraction a_delta_time = scls::Fraction(1, 100);
        // If the dynamic collision should be ignored or not
        bool a_ignore_dynamic_collisions = false;
        // If the object is loaded in the map
        bool a_loaded_in_map = false;
        // Standard restitution of the object
        double a_restitution = 1;
        // If the physic should be saved or not
        bool a_save_to_xml_text = true;
        // If the object is static or not
        bool a_static = true;
        // If the object use gravity or not
        bool a_use_gravity = true;
        // Used physic cases
        std::vector<Physic_Case*> a_used_physic_case;
    };
    typedef Physic_Object_3D::Collision_3D Collision_3D;
    typedef Physic_Object_3D::Physic_Case Physic_Case_3D;

    //******************
    // Physic engine
    //******************

    // Physic engine
    class Physic_Engine_3D {
        // Class representating a physic engine
    public:
        // Physic_Engine_3D constructor
        Physic_Engine_3D(){};

        // Clears the physic engine
        void clear(){a_physic_map.clear();a_physic_objects.clear();a_physic_map_start_x=0;a_physic_map_start_y=0;};

        // Adds a physic object
        void add_physic_object(std::shared_ptr<Physic_Object_3D> new_object){a_physic_objects.push_back(new_object);}
        // Deletes the physic in a case
        void delete_physic_object_case(Physic_Object_3D* to_delete);
        // Loads 100 X 100 physic map
        void load_physic_map(int middle_loading_x, int middle_loading_y, int middle_loading_z);
        // Creates and return a new physic object
        std::shared_ptr<Physic_Object_3D> new_physic_object(std::weak_ptr<Transform_Object_3D> object);
        // Returns a physic case by its coordinates
        Physic_Case_3D* physic_case(int x, int y, int z);
        // Returns a list of physic object in a rectr
        std::vector<std::shared_ptr<Physic_Object_3D>> physic_objects_in_rect(double x, double y, double width, double height);

        // Raycasts the map
        struct Raycast_Result{std::shared_ptr<Collision_3D::Collision_Event> collision;Collision_3D::Collision_Event* collision_event(){return collision.get();};Point_3D position;};;
        Raycast_Result raycast(double x_start, double y_start, double x_direction, double y_direction, double distance);

        // Soft reset the engine
        void soft_reset(double used_delta_time);
        // Updates the physic
        int update_physic(double multiplier);
        int update_physic_early(double multiplier);
        int update_physic_late(double multiplier);

        // Getters and setters
        inline std::vector<std::vector<std::vector<std::shared_ptr<Physic_Case_3D>>>>& physic_map(){return a_physic_map;};
        inline std::vector<std::shared_ptr<Physic_Object_3D>>& physic_objects(){return a_physic_objects;};
    private:

        // Physic map
        std::vector<std::vector<std::vector<std::shared_ptr<Physic_Case_3D>>>> a_physic_map;
        int a_physic_map_start_x = 0;int a_physic_map_start_y = 0;int a_physic_map_start_z = 0;

        // Physic objects
        std::vector<std::shared_ptr<Physic_Object_3D>> a_physic_objects;
    };
}
