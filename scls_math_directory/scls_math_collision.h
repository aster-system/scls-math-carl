//******************
//
// scls_math_collision.h
//
//******************
// Presentation :
//
// SCLS is a project containing base functions for C++.
// It can also be use in any projects.
//
// The Math "Carl" part represents the mathematical part of SCLS.
// It is named after one one of the greatest mathematician of all times, Carl Freiderich Gauss.
//
// This file contains some tools to use physic collisions in SCLS.
//
//******************
//
// License (LGPL V3.0) :
//
// Copyright (C) 2024 by Aster System, Inc. <https://aster-system.github.io/aster-system/>
// This file is part of SCLS.
// SCLS is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
// SCLS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with SCLS. If not, see <https://www.gnu.org/licenses/>.
//

// Include the good header file
#include "scls_math_geometry_core.h"

// The namespace "scls" is used to simplify the all.
namespace scls {
    // Possible types of collision
    enum Collision_Type {GCT_Circle, GCT_Line, GCT_Rect};

    // Physic in a graphic object
    class Graphic_Physic {
        // Class representating a physic handler in a graphic object
    public:

        // Collision
        class Collision {
            // Class representating a collision in a graphic object
        public:

            // Base of a collision
            struct Collision_Event {
                // Collision constructor
                Collision_Event(std::weak_ptr<Collision> collision_parent):a_collision_parent(collision_parent){}

                // This object
                Collision* collision_parent() const {return a_collision_parent.lock().get();};
                std::weak_ptr<Collision> collision_parent_weak_ptr() const {return a_collision_parent;};

                // If the collision happens or not
                bool happens = false;
                Collision_Type type;

                // Other collided object
                Collision* other_collision(){return a_other_collision.lock().get();};
                Collision_Event* other_collision_event(){return a_other_collision_event.lock().get();};
                Graphic_Physic* other_physic(){return a_other_collision.lock().get()->attached_physic();};
                void set_other_collision_event(std::weak_ptr<Collision_Event> new_other_collision_event){a_other_collision_event = new_other_collision_event;a_other_collision = other_collision_event()->collision_parent_weak_ptr();};

                // Acceleration generated by the force
                scls::Point_2D acceleration;

            private:
                // Parent collision of this object
                std::weak_ptr<Collision> a_collision_parent;

                // Other collision object
                std::weak_ptr<Collision> a_other_collision;
                std::weak_ptr<Collision_Event> a_other_collision_event;
            };

            // Datas for a circle collision
            struct Collision_Event_Circle : public Collision_Event {
                // Collision_Circle constructor
                Collision_Event_Circle(std::weak_ptr<Collision> collision_parent):Collision_Event(collision_parent){type = Collision_Type::GCT_Circle;};

                // Angle of the collision
                double angle;
            };

            // Datas for a rect collision
            struct Collision_Event_Rect_Rect : public Collision_Event {
                // Possible side for collision
                #define PLEOS_PHYSIC_RECT_COLLISION_BOTTOM 3
                #define PLEOS_PHYSIC_RECT_COLLISION_LEFT 2
                #define PLEOS_PHYSIC_RECT_COLLISION_RIGHT 4
                #define PLEOS_PHYSIC_RECT_COLLISION_TOP 1

                // Collision_Rect_Rect constructor
                Collision_Event_Rect_Rect(std::weak_ptr<Collision> collision_parent):Collision_Event(collision_parent){type = Collision_Type::GCT_Rect;};

                // Distance between the colliding side
                double distance;
                // Sides of the collision
                bool side_bottom = false;
                bool side_left = false;
                bool side_right = false;
                bool side_top = false;
            };

            // Collision constructor
            Collision(std::weak_ptr<Graphic_Physic> attached_physic, std::weak_ptr<scls::Transform_Object_2D> attached_transform):a_attached_physic(attached_physic),a_attached_transform(attached_transform){};

            // Getters and setters
            scls::Fraction absolute_height() const;
            scls::Point_2D absolute_scale() const;
            scls::Fraction absolute_width() const;
            double absolute_x() const;
            double absolute_x_1() const;
            double absolute_x_2() const;
            double absolute_y() const;
            double absolute_y_1() const;
            double absolute_y_2() const;
            Graphic_Physic* attached_physic()const;
            scls::Transform_Object_2D* attached_transform()const;
            double direct_x_1() const;
            double direct_x_2() const;
            double direct_y_1() const;
            double direct_y_2() const;
            double max_absolute_x() const;
            double max_absolute_y() const;
            double min_absolute_x() const;
            double min_absolute_y() const;
            double max_absolute_x_next() const;
            double max_absolute_y_next() const;
            double min_absolute_x_next() const;
            double min_absolute_y_next() const;
            scls::Point_2D position_next() const;
            void set_type(Collision_Type new_type);
            void set_x_1(scls::Fraction new_x_1);
            void set_x_2(scls::Fraction new_x_2);
            void set_y_1(scls::Fraction new_y_1);
            void set_y_2(scls::Fraction new_y_2);
            Collision_Type type()const;
            double x_1() const;
            double x_2() const;
            double y_1() const;
            double y_2() const;

        private:
            // Attached physic
            std::weak_ptr<Graphic_Physic> a_attached_physic;
            // Attached object
            std::weak_ptr<scls::Transform_Object_2D> a_attached_transform;
            // Type of the collision
            Collision_Type a_type = Collision_Type::GCT_Line;

            // Two points (needed for lines)
            scls::Fraction a_x_1 = 0;scls::Fraction a_y_1 = 0;
            scls::Fraction a_x_2 = 0;scls::Fraction a_y_2 = 0;
        };

        // Physic case
        struct Physic_Case{
            // Static objects in the case
            inline void delete_static_object_collision(Collision* object){for(int i=0;i<static_cast<int>(static_objects_collisions.size());i++){if(static_objects_collisions[i].lock().get()==object){static_objects_collisions.erase(static_objects_collisions.begin() + i);static_objects_collisions_physic.erase(static_objects_collisions_physic.begin() + i);break;}}};
            std::vector<std::weak_ptr<Collision>> static_objects_collisions;
            std::vector<std::weak_ptr<Graphic_Physic>> static_objects_collisions_physic;

            // Position
            scls::Point_2D position;
            inline int x(){return position.x();};
        };

        // Graphic_Physic constructor
        Graphic_Physic(std::weak_ptr<scls::Transform_Object_2D> attached_transform):a_attached_transform(attached_transform){};

        // Deletes the object
        void delete_object();
        // If the object should be deleted or not
        bool should_delete() const;
        // Softs reset the object
        virtual void soft_reset();

        // Add a line / rect collision to the graphic object
        void add_collision(std::shared_ptr<Collision> collision);
        void add_collision(double x_1, double y_1, double x_2, double y_2);
        void add_collision(double x_1, double y_1, double x_2, double y_2, double restitution);
        // Checks if a collision occurs with an another collision
        void check_collision(std::shared_ptr<Collision> collision, Graphic_Physic* other_object);
        // Returns a new a collision to the graphic object
        std::shared_ptr<Collision> new_collision(Collision_Type type);
        std::shared_ptr<Collision> new_collision(){return new_collision(Collision_Type::GCT_Rect);};

        // Accelerates the object
        inline void accelerate(scls::Point_2D_Formula acceleration){a_attached_transform.lock().get()->accelerate(acceleration);};
        inline void accelerate(scls::Point_2D acceleration){a_attached_transform.lock().get()->accelerate(acceleration);};
        inline void accelerate_x(double acceleration){a_attached_transform.lock().get()->accelerate_x(acceleration);};
        inline void accelerate_y(double acceleration){a_attached_transform.lock().get()->accelerate_y(acceleration);};
        // Next movement generated by the velocity
        inline double next_movement_x()const{return a_attached_transform.lock().get()->next_movement_x();};
        inline double next_movement_y()const{return a_attached_transform.lock().get()->next_movement_y();};
        // Remove the X / Y velocity
        inline void remove_x_velocity(){a_attached_transform.lock().get()->set_velocity_x(0);};
        inline void remove_y_velocity(){a_attached_transform.lock().get()->set_velocity_y(0);};
        // Updates raw velocity
        inline void update_raw_velocity(){a_attached_transform.lock().get()->update_raw_velocity();};

        // Moves the object
        void __move(scls::Point_2D point){scls::Transform_Object_2D* t=a_attached_transform.lock().get();t->set_x(t->x() + point.x());t->set_y(t->y() + point.y());};
        void __move(){scls::Transform_Object_2D* t=a_attached_transform.lock().get();t->add_x(next_movement_x());t->add_y(next_movement_y());};

        // Physic
        virtual int collision_height(){return std::ceil(max_absolute_y_next()) - std::floor(min_absolute_y_next());};
        virtual int collision_width(){return std::ceil(max_absolute_x_next()) - std::floor(min_absolute_x_next());};
        virtual int collision_x_start(){return std::floor(min_absolute_x_next());};
        virtual int collision_y_start(){return std::floor(min_absolute_y_next());};

        // Precise next movement
        inline double max_absolute_x_next() const {return attached_transform()->max_absolute_x_next();};
        inline double max_absolute_y_next() const {return attached_transform()->max_absolute_y_next();};
        inline double min_absolute_x_next() const {return attached_transform()->min_absolute_x_next();};
        inline double min_absolute_y_next() const {return attached_transform()->min_absolute_y_next();};
        inline scls::Point_2D position_next() const {return attached_transform()->position_next();};
        inline double x_next() const {return attached_transform()->x_next();};
        inline double y_next() const {return attached_transform()->y_next();};

        // Calculates the point of the trajectory of the function
        std::vector<scls::Point_2D> trajectory_points(int point_number, double time_separation);

        // Getters and setters
        inline scls::Transform_Object_2D* attached_transform()const{return a_attached_transform.lock().get();};
        inline std::vector<std::shared_ptr<Collision>>& collisions(){return a_collisions;};
        inline std::vector<std::shared_ptr<Collision::Collision_Event>>& current_collisions_results(){return a_current_collisions_results;};
        inline scls::Fraction delta_time() const {return a_delta_time;};
        inline bool ignore_dynamic_collisions() const {return a_ignore_dynamic_collisions;};
        inline bool is_static() const {return a_static;};
        inline bool loaded_in_map() const {return a_loaded_in_map;};
        inline bool moved_during_this_frame() const {return attached_transform()->moved_during_this_frame();};
        inline scls::Point_2D position() const {return a_attached_transform.lock().get()->position();};
        inline scls::Point_2D raw_velocity() const {return a_attached_transform.lock().get()->raw_velocity();};
        inline scls::Fraction raw_velocity_x() {return raw_velocity().x();};
        inline scls::Fraction raw_velocity_y() {return raw_velocity().y();};
        inline double restitution() const {return a_restitution;};
        inline bool save_to_xml_text() const {return a_save_to_xml_text;};
        inline void set_delta_time(scls::Fraction new_delta_time){a_delta_time = new_delta_time;attached_transform()->set_delta_time(new_delta_time);for(int i = 0;i<static_cast<int>(a_collisions.size());i++){a_collisions.at(i).get()->attached_transform()->set_delta_time(new_delta_time);}};
        inline void set_ignore_dynamic_collisions(bool new_ignore_dynamic_collisions){a_ignore_dynamic_collisions = new_ignore_dynamic_collisions;};
        inline void set_loaded_in_map(bool new_loaded_map){a_loaded_in_map = new_loaded_map;};
        inline void set_restitution(double new_restitution){a_restitution = new_restitution;};
        inline void set_save_to_xml_text(bool new_save_to_xml_text){a_save_to_xml_text = new_save_to_xml_text;};
        inline void set_static(bool new_static) {a_static = new_static;}
        inline void set_this_object(std::weak_ptr<Graphic_Physic> this_object) {a_this_object = this_object;}
        inline void set_use_gravity(bool new_use_gravity){a_use_gravity = new_use_gravity;};
        inline void set_velocity(scls::Point_2D new_velocity){attached_transform()->set_velocity(new_velocity);};
        inline void set_velocity_start(scls::Point_2D_Formula new_velocity){a_velocity_start = new_velocity;};
        inline void set_velocity_x(double new_velocity_x, bool with_delta_time){if(with_delta_time){a_attached_transform.lock().get()->set_velocity_x(new_velocity_x / a_delta_time.to_double());}else{a_attached_transform.lock().get()->set_velocity_x(new_velocity_x);}};
        inline void set_velocity_x(double new_velocity_x){set_velocity_x(new_velocity_x, false);};
        inline void set_velocity_y(double new_velocity_y, bool with_delta_time){if(with_delta_time){a_attached_transform.lock().get()->set_velocity_y(new_velocity_y / a_delta_time.to_double());}else{a_attached_transform.lock().get()->set_velocity_y(new_velocity_y);}};
        inline void set_velocity_y(double new_velocity_y){set_velocity_y(new_velocity_y, false);};
        inline bool use_gravity() const {return a_use_gravity;};
        inline std::vector<Physic_Case*>& used_physic_case(){return a_used_physic_case;};
        inline scls::Point_2D velocity() const {return a_attached_transform.lock().get()->velocity();};
        inline double velocity_x() {return velocity().x();};
        inline double velocity_y() {return velocity().y();};
        inline scls::Fraction x() {return attached_transform()->x();};
        inline scls::Fraction y() {return attached_transform()->y();};
    private:
        // Attached object
        std::weak_ptr<scls::Transform_Object_2D> a_attached_transform;
        // Collisions in the physic object
        std::vector<std::shared_ptr<Collision>> a_collisions;
        // Current collision of the object
        std::vector<std::shared_ptr<Collision::Collision_Event>> a_current_collisions_results;
        // This object
        std::weak_ptr<Graphic_Physic> a_this_object;

        // Delta time of the object
        scls::Fraction a_delta_time = scls::Fraction(1, 100);
        // If the dynamic collision should be ignored or not
        bool a_ignore_dynamic_collisions = false;
        // If the object is loaded in the map
        bool a_loaded_in_map = false;
        // Standard restitution of the object
        double a_restitution = 1;
        // If the physic should be saved or not
        bool a_save_to_xml_text = true;
        // If the object is static or not
        bool a_static = true;
        // If the object use gravity or not
        bool a_use_gravity = true;
        // Velocity at the start of the animation
        scls::Point_2D_Formula a_velocity_start = scls::Point_2D_Formula(0, 0);
        // Used physic cases
        std::vector<Physic_Case*> a_used_physic_case;
    };
    typedef Graphic_Physic::Collision Collision;
    typedef Graphic_Physic::Physic_Case Physic_Case;

    // Checks the collision between two circles
    void check_collision_circle_circle_maths(Point_2D position, Point_2D other_position, Point_2D scale, Point_2D other_scale, Point_2D velocity, Point_2D velocity_other, bool can_be_in_each_other, double object_restitution, double other_restitution, bool object_is_static, bool other_is_static);

    // Checks the collision between a circle and a line
    void check_collision_circle_line_maths(double x_circle, double y_circle, double width_circle, Point_2D position_next_circle, Point_2D velocity_circle, double x_1, double y_1, double x_2, double y_2);

    //******************
    // Physic engine
    //******************

    // Physic engine
    class Physic_Engine {
        // Class representating a physic engine
    public:
        // Physic_Engine constructor
        Physic_Engine(){};

        // Clears the physic engine
        void clear(){a_physic_map.clear();a_physic_objects.clear();a_physic_map_start_x=0;a_physic_map_start_y=0;};

        // Adds a physic object
        void add_physic_object(std::shared_ptr<Graphic_Physic> new_object){a_physic_objects.push_back(new_object);}
        // Deletes the physic in a case
        void delete_physic_object_case(Graphic_Physic* to_delete);
        // Loads 100 X 100 physic map
        void load_physic_map(int middle_loading_x, int middle_loading_y);
        // Creates and return a new physic object
        std::shared_ptr<Graphic_Physic> new_physic_object(std::weak_ptr<Transform_Object_2D> object);
        // Returns a physic case by its coordinates
        Physic_Case* physic_case(int x, int y);
        // Returns a list of physic object in a rectr
        std::vector<std::shared_ptr<Graphic_Physic>> physic_objects_in_rect(double x, double y, double width, double height);

        // Raycasts the map
        struct Raycast_Result{std::shared_ptr<Collision::Collision_Event> collision;Point_2D position;};
        Raycast_Result raycast(double x_start, double y_start, double x_direction, double y_direction, double distance);

        // Soft reset the engine
        void soft_reset(double used_delta_time);
        // Updates the physic
        int update_physic(double multiplier);
        int update_physic_early(double multiplier);
        int update_physic_late(double multiplier);

        // Getters and setters
        inline std::vector<std::vector<std::shared_ptr<Physic_Case>>>& physic_map(){return a_physic_map;};
        inline std::vector<std::shared_ptr<Graphic_Physic>>& physic_objects(){return a_physic_objects;};
    private:

        // Physic map
        std::vector<std::vector<std::shared_ptr<Physic_Case>>> a_physic_map;
        int a_physic_map_start_x = 0;int a_physic_map_start_y = 0;

        // Physic objects
        std::vector<std::shared_ptr<Graphic_Physic>> a_physic_objects;
    };
}
